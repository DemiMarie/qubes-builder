#!/bin/bash --

# Usage: $0 <source-dir> [<ref>]
# Example refs:
#  master
#  HEAD
#  mainstream/master
# Default ref: HEAD
set -euo pipefail
: "${KEYRING_DIR_GIT=}" "${NO_CHECK=}" "${DEBUG=}" "${VERBOSE=0}"
unset GNUPGHOME

case $0 in (/*) dir=${0%/*};; (*/*) dir=./${0%/*};; (*) dir=.;; esac
BUILDER_DIR=$dir/..
export BUILDER_DIR

# shellcheck source=scripts/common
. "$dir/common"

[ "$DEBUG" = "1" ] && set -x

if [ "${NO_CHECK-}" != "" ]; then
    echo 'Sorry, NO_CHECK is no longer supported'>&2
    echo 'If you really want to turn of signature checking, use “CHECK=insecure-no-check”'>&2
    exit 1
fi

case ${CHECK=signed-tag} in
(signed-tag|signed-tag-or-commit) :;;
(insecure-no-check)
    echo 'Please avoid calling this script if you don’t want signatures checked'>&2
    exit 1
    ;;
(*)
    printf 'Invalid value for $CHECK: %q\n' "$CHECK">&2
    exit 1
    ;;
esac

if [ -n "$KEYRING_DIR_GIT" ]; then
    GNUPGHOME="$(readlink -m "$KEYRING_DIR_GIT")"
    export GNUPGHOME
    if [ ! -d "$GNUPGHOME" ]; then
        mkdir -p "$GNUPGHOME"
        chmod 700 "$GNUPGHOME"
        gpg --import qubes-developers-keys.asc
        # Trust Qubes Master Signing Key
        echo '427F11FD0FAA4B080123F01CDDFA1A3E36879494:6:' | gpg --import-ownertrust
    fi
    if [ qubes-developers-keys.asc -nt "$GNUPGHOME/pubring.gpg" ]; then
        gpg --import qubes-developers-keys.asc
        touch "$GNUPGHOME/pubring.gpg"
    fi
    maintainers=$(env | grep -oP '^ALLOWED_COMPONENTS_[a-fA-F0-9]{40}') || :
    for maintainer in $maintainers
    do
        read -a allowed_components <<<"${!maintainer}"
        COMPONENT="$(basename "$1")"
        COMPONENT="${COMPONENT//./builder}"
        if elementIn "$COMPONENT" "${allowed_components[@]}"; then
            keyid=${maintainer#ALLOWED_COMPONENTS_}
            gpg --import "$BUILDER_DIR/keys/$keyid.asc" || exit 1
            echo "$keyid:6:" | gpg --import-ownertrust
        fi
    done
    gpgconf --kill gpg-agent
fi

verify_gpg_output () {
    local "content=$1" newsig_number
    newsig_number=$(printf %s\\n "$content" | grep -c '^\[GNUPG:] NEWSIG') || return 1
    [ "$newsig_number" = 1 ] && {
        printf %s\\n "$content" |
        grep '^\[GNUPG:] TRUST_\(FULLY\|ULTIMATE\) 0 pgp$' >/dev/null
    }
}

git_check_trust () {
    if [[ $# -ne 2 ]] || ! { [[ $1 = 'commit' ]] || [[ $1 = 'tag' ]]; }; then
        echo "Usage: git_check_trust [commit|tag] hash">&2
        exit 1
    fi
    local content
    content=$(git -c gpg.minTrustLevel=fully "verify-$1" --raw -- "$2" 2>&1 >/dev/null) &&
    verify_gpg_output "$content"
}

verify_tag() {
    local "tag=refs/tags/$1" "expected_hash=$2" hash
    if ! hash="$(git rev-parse -q --verify "$tag^{commit}")"; then
        echo "---> Failed to get tag hash for tag $tag">&2
        return 1
    elif ! [ "$hash" = "$expected_hash" ]; then
        echo "---> Tag has wrong hash (found $hash, expected $expected_hash)">&2
        return 1
    fi
    if git_check_trust tag "$tag_hash"; then
        printf %s\\n "---> Good tag ${tag:10}"
        return 0
    else
        return 1
    fi
}

verify_git_hash () {
    local expected_hash
    for expected_hash; do
        if [[ "${#expected_hash}" -ne 40 ]] && [[ "${#expected_hash}" -ne 64 ]]; then
            echo "---> Bad Git hash value (wrong length); failing" >&2
            exit 1
        elif ! [[ "$expected_hash" =~ ^[a-f0-9]+$ ]]; then
            echo "---> Bad Git hash value (bad character); failing" >&2
            exit 1
        fi
    done
}

VALID_TAG_FOUND=0

pushd "$1" > /dev/null || exit 2

case $# in
    (1) expected_hash=$(git rev-parse --verify -q HEAD);;
    (2) expected_hash=$2;;
    (*) echo 'USAGE: verify-git-tag directory [revision]'>&2; exit 1;;
esac

verify_git_hash "$expected_hash"

unset tags tag
tags="$(git tag "--points-at=$expected_hash"|head -c 500)" || exit 1
for tag in $tags; do
    if verify_tag "$tag" "$expected_hash"; then
        VALID_TAG_FOUND=1
    elif [ "0$VERBOSE" -ge 1 ]; then
        echo "---> One of signed tag cannot be verified: $tag"
    fi
done

if [ -z "${tag+x}" ]; then
    echo "---> No tag pointing at $expected_hash"
    if content=$(git_check_trust verify-commit --raw -- "$expected_hash" 2>&1 >/dev/null) &&
        verify_gpg_output "$content"; then
        case $CHECK in
        (signed-tag-or-commit)
            echo "---> $expected_hash does not have a signed tag"
            echo "---> However, it is signed by a trusted key, and \$CHECK is set to $CHECK"
            echo "---> Accepting it anyway"
            exit 0
            ;;
        (signed-tag)
            echo "---> $expected_hash is a commit signed by a trusted key ― did the signer forget to add a tag?"
            exit 1
            ;;
        (*) # not reached
            echo 'internal error (this is a bug)'>&2
            exit 1
            ;;
        esac
    fi
    exit 1
elif [ "$VALID_TAG_FOUND" -ne 1 ]; then
    echo "---> No valid signed tag found!"
    if [ "0$VERBOSE" -eq 0 ]; then
        echo "---> One invalid tag: $tag"
    fi
    exit 1
fi

exit 0
